---
title: 前端面试题汇总
toc: true
data: 2022-08-03 14:52:28
tags: 面试题
categories: 面试
---

*常见前端面试题*   <!--more-->

#### 基本算法/数据结构相关

- 链表

  - 数组是一个有序的、线型的数据结构，是连续的，在底层中开辟了一组连续的内存空间
  - 链表可以指向底层中一组不连续的内存空间
  - 分类：单向链表、双向链表、单向循环链表、双向循环链表、环形链表(循环链表是一种特殊的环形链表)

  ```
  // 节点类
  class Node {
    constructor(element) {
      this.element = element;
      this.next = null;
    }
  }
  
  // 单向链表
  class LinkedList {
    constructor() {
      this.size = 0;
      this.head = null;
    }
    // 添加元素的方法
    // 原理：先判断链表是否为空，如果为空直接创建为头元素即可，否则找到最后一个元素节点，然后追加到后面
    append(element) {
      //   创建节点
      let node = new Node(element);
      //   判断链表是否为空
      if (this.head === null) {
        this.head = node;
      } else {
        // 通过getNode方法找到最后一个元素
        let current = this.getNode(this.size - 1);
        current.next = node;
      }
      this.size++;
    }
  
    //   插入元素的方法
    insert(position, element) {
      //   边界判断
      if (position < 0 || position > this.size) {
        throw new Error("position out range");
      }
  
      // 创建新节点
      let node = new Node(element);
      // 判断是在头添加还是其他位置添加
      if (position === 0) {
        node.next = this.head;
        this.head = node;
      } else {
        let pre = this.getNode(position - 1);
        node.next = pre.next;
        pre.next = node;
      }
      this.size++;
    }
  
    // 删除元素的方法
    remove(position) {
      if (position < 0 || position >= this.size) {
        throw new Error("position out range");
      }
      let current = this.head;
      if (position === 0) {
        this.head = current.next;
      } else {
        let pre = this.getNode(position - 1);
        current = pre.next;
        pre.next = current.next;
      }
      this.size--;
    }
  
    //   查找元素的方法
    indexOf(element) {
      let current = this.head;
      for (let i = 0; i < this.size; i++) {
        if (current.element === element) {
          return i;
        }
        current = current.next;
      }
      return -1;
    }
  
    //   获取节点的方法
    getNode(index) {
      if (index < 0 || index >= this.size) {
        throw new Error("out range");
      }
      let current = this.head;
      for (let i = 0; i < index; i++) {
        current = current.next;
      }
      return current;
    }
  }
  
  let ll = new LinkedList();
  ll.append(1);
  ll.append(2);
  ll.append(3);
  ll.insert(3, 5);
  ll.insert(2, 0);
  // ll.remove(0);
  ll.remove(2);
  console.dir(ll, {
    depth: 100,
  });
  /*
  LinkedList {
    size: 4,
    head: Node {
      element: 1,
      next: Node {
        element: 2,
        next: Node { element: 3, next: Node { element: 5, next: null } }
      }
    }
  }
   */
  console.log(ll.indexOf(2)); // 1
  console.log(ll.indexOf(0)); // -1
  console.log(ll.indexOf(3)); // 2
  
  ```


### 综合问题

#### 你对前端是怎么理解的？

- 在没有前端岗位之前，一个项目中负责后台功能逻辑处理的代码和前端页面展示代码混在一起，不免会给开发和维护带来各种问题，渐渐的就开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。前端做的就是用户可以直接看见并交互的界面，即浏览器上运行的用户交互界面（浏览器端，客户端），核心工作有数据渲染、用户体验、性能优化。
  - 数据渲染（根据数据设计html结构，渲染页面，展示页面.......）
  - 用户体验（网页效果，表单验证，其他功能......）
  - 性能优化（精灵图，懒加载 ，代码的压缩合并，图片的压缩合并，css的预编译.......）

#### 移动端页面优化

- 随着滑动的dom越来越长，会出现卡顿的现象，进而降低用户体验，于是可视区渲染方案出来。

- 可视区渲染就像一句话说的：敌不动我动，山不就我我就山。

  - 可视区渲染原理：
    - 1，有个滚动区域，下面的content类，要求overflow：auto，也就是可以使用滚动；在实际项目开发中这个根据可视区窗口大小变化
    - 2，一个足够高的渲染盒子，下面中viewArea类，其高度等于所有内容条数x单条内容高度，在实际项目中这个会受限于手机html的最大高度限制
    - 3，可视区显示的内容条数viewArea类里面的内容，内容多少可以通过pageSize控制
    - 4，通过监听滚动事件，触发可视区内容更新，包括更新呈现的内容以及更新内容的位置，后者其实是人为制造了一种滚动效果

- PC端性能优化的方法都可以应用到移动端来，而且移动端的时间消耗大部分在资源下载过程

- 移动网站加载速度缓慢的原因

  - 1、网站服务器

    - 网站服务器（比如软件），默认情况下运行缓慢，或者尚未针对加载速度最大化进行合适的配置
  - 2、虚拟主机解决方案

    - 移动网站被托管于一个相对缓慢的虚拟主机解决方案（或硬件）中，或者这个网站流量非常高，经常超出虚拟主机可以处理的流量水平。
  - 3、网站浏览器缓存

    - 移动网站尚未被配置使用网站浏览器缓存
  - 4、文件大小

    - 移动网站页面要求下载资源，并且这些资源的文件大小加起来过大了。
  - 5、HTTP请求

    - 移动网站页面要求下载过多的资源，比如图片、音频、视频、js、css等文件，这会导致过多的http请求，每一次http请求都会执行三次握手，每次握手都会消耗较多的时间。
  - 6、DNS查询

    - 移动网站页面要求从过多的不同的主机名处下载各种资源，比如图片、音频、视频、js、css等文件，这会增加DNS查询次数，并且使网页加载速度变慢。

- 7、总体连接速度缓慢
        

      - 一些有意或者无意的设置（过多的重定向、无效的请求等），会大大减慢页面加载速度

  - 8、CDN

    - 移动网站的用户大部分来自于面积极大的国家（或者横跨非常大的地理位置），但却没有使用CDN

  - 9、网络自身速度缓慢

  - 网站服务器与请求移动网站页面的用户（比如浏览器）之间的网络连接较慢。

  - 优化方案

    - 加载优化、图片优化、CSS优化、js优化、渲染优化

    - 加载优化

      - 1、减少HTTP请求数目，因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求
        数不能超过4个。下面介绍减少HTTP请求数目的方法：
          - CSS Sprites：国内俗称 CSS 精灵，即雪碧图，这是将多张小图片合并成一张图片，达到减少 HTTP 请求的一种解决方案。可以通过 CSS background 属性来访问图片内容。这种方案同时还可以减少图片总字节数，节省命名词汇量（由命名多张图片文件变成一张）。
          - 合并 CSS 和 JS 文件：现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个CSS 或者 多个 JS 合并成一个文件。
          - 采用 lazyLoad：俗称懒加载，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。

      - 2、缓存，使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）。
        - 缓存一切可缓存的资源
        - 使用长Cache（使用时间戳更新Cache）
        - 使用外联式引用CSS、JavaScript

      - 3、压缩HTML、CSS、JavaScript减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZip。
        - A、压缩（例如，多余的空格、换行符和缩进、注释）
        - B、启用GZip

      - 4、使用首屏加载（对一些重要内容优先加载显示，一些次要内容可延迟加载）首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏
        的快速显示做优化。

      - 5、按需加载（按需加载可能会导致很多的重绘，影响渲染性能）将不影响首屏的资源和当前屏幕资源不用的资源，放到用户需要时在加载，可以大大提升重要资源的显示速度和降低总体流量。
        - A、LazyLoad
        - B、滚屏加载
        - C、通过Media Query加载

      - 6、预加载，大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面，但Loading时间过长，会造成用户流失。
        - A、可感知Loading(如进入空间游戏的Loading)
        - B、不可感知的Loading（如提前加载下一页）
        - C、对用户行为分析，可以在当前页加载下一页资源，提升速度。

      - 7、避免重定向，重定向会影响加载速度，所以在服务器正确设置，避免重定向。

      - 8、异步加载第三方资源，第三方资源不可控，会影响页面的加载和显示，因此要异步加载第三方资源。

      - 9、控制资源文件加载优先级，资源文件处理不当会阻塞页面加载、渲染，因此在使用时需要注意以下几点：
        - A、CSS写在头部，JavaScript写在尾部或异步。
        - B、避免图片和iFrame等的空Src，空Src会重新加载当前页面，影响速度和效率。
        - C、尽量避免重设图片大小，重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能。
        - D、图片尽量避免使用DataURL，DataURL图片没有使用图片的压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长。

    - 图片优化

      - 1、压缩图片，图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示。
        A、使用智图压缩（制图是基于window系统的一款压缩图片的软件，转化为合适的图片格式）
        B、使用其它方式代替图片（使用CSS3；使用SVG；使用IconFont）
        C、使用Srcset（设置响应式图片，根据不同的屏幕分辨率和设备像素比，尽可能选择高分辨率的图片）
        D、选择合适格式的图片（webP优于JPG；PNG8优于GIF）
        E、选择合适的大小（首次加载不大于1014KB；基于手机屏幕一般宽度不宽于640）
        注意：过度压缩图片大小会影响图片显示效果。

    - CSS优化
      1、尽量避免在HTML标签中使用style属性。( 因为在HTML标签中的style会阻塞页面的渲染 )
      2、避免使用CSS表达式。（因为其执行频率很高，当页面滚动或者鼠标移动的时候，就会执行，这会带来很大的性能损耗）
      3、移除空的CSS规则。（空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则）。
      4、正确使用display的属性。（display属性会影响页面的渲染）。
          （a）、display:inline后不应该再使用width、height、margin、padding以及float
          （b）、display:inline-block后不应该再使用float
          （c）、display:block后不应该再使用vertical-align
          （d）、display:table-*后不应该再使用margin或者float
      5、不滥用float。（float在渲染时计算量比较大，尽量减少使用）。
      6、不滥用Web字体。（Web字体需要下载，解析，重绘当前页面，尽量减少使用）。
      7、不声明过多的font-size。（过多的font-size引发CSS树的效率）。
      8、值为0时不需要任何单位。（为了浏览器的兼容性和性能，值为0时不要带单位）。
      9、标准化各种浏览器前缀
          （a）、无前缀应放在最后。
          （b）、CSS动画只用（-webkit-，无前缀）两种即可。
          （c）、其它前缀为“-webkit- -moz- -ms-无前缀”四种（-o-Opera浏览器改用blink内核，所以淘汰）。
      10、避免让选择符看起来像正则表达式。
      11、高级选择器执行耗时长且不易读懂，避免使用。

    - js优化
      1、用一个变量保存列表的length的值，避免每次执行的时候到要计算该值。
      2、缓存DOM的选择与计算，避免每次Dom选择都要重新计算。
      3、尽量使用ID选择器，ID选择器是最快的。（因为用id访问时，只要找到元素就停止在DOM上查找；而用其他选择器去查找元素则要对DOM所有节点都访问一遍。）
      4、减少重绘和回流
          （a）、避免不必要的DOM操作
          （b）、尽量改变Class而不是Style，使用classList代替className
          （c）、避免使用document.write
          （d）、减少drawImage
      5、尽量使用事件代理，避免批量绑定事件。（当网页中需要触发事件的对象比较多的时候，为了避免内存泄漏，我们把事件委托到其父对象上，借助事件冒泡机制，可以将事件委托到body，document等元素上，这样等于一个页面就只有一个事件触发，避免直接把事件添加到多个对象上）
      6、touch事件优化，使用touchstart、touchend代替click。（响应速度快，但应注意touch响应过快，易引发误操作)。

    - 渲染优化
      1、HTML使用viewport。（viewport可以加速页面的渲染），如以下代码：
          `<meta name=”viewport” content=”width=device-width, initial-scale=1″>`

      2、减少DOM节点

      3、动画优化
      （a）、尽量使用CSS3动画。
      （b）、合理使用requestAnimationFrame动画代替setTimeout。
      （c）、适当使用Canvas动画，5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）。

      4、高频事件优化。（ Touchmove、Scroll事件可导致多次渲染）
      （1）、使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染。
      （2）、增加响应变化的时间间隔，减少重绘次数。

      5、GPU加速
      CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用。
      注意：过度使用这些属性，会引发手机过度耗电

#### DOM操作为什么会影响性能？

在浏览器中，DOM的实现和ECMAScript的实现是分离的。例如，在IE中，ECMAScript的实现在jscript.dll中，而DOM的实现在mshtml.dll中；在chrome中使用webkit的WebCore
处理DOM和渲染，但ECMAScript是在V8引擎中实现的，其他浏览器情况类似，所以通过Javascript调用dom接口，是相当于两个模块的交互。相比较在同一模块中的调用，这种
跨模块的调用其性能损耗是很高的，但DOM操作对性能影响最大是因为它导致了浏览器的重绘和重排。

#### 通过call,apply,bind修改this的指向。

    2.1.call方法：第一个参数就是this的指向，从第二个参数开始就是函数自身的参数。
    2.2.apply方法：第一个参数就是this的指向，第二个参数是一个数组或者类数组，数组项就是函数自身的参数。
    2.3.bind方法：第一个参数就是this的指向，从第二个参数开始就是函数自身的参数，返回的是函数体，需要再次调用。

#### 浏览器渲染原理

- 浏览器将获取的HTML文档解析成DOM Tree（DOM树）
- 将Css样式表，解析成CSSOM Tree（CSS树）
- 将DOM和CSSOM合并为渲染树（rendering tree），这个过程称之为attachment
- 渲染树的每个元素经过精确的计算后，给出坐标，这个过程称之为layout
- 将渲染树的各个节点绘制到屏幕上，这个过程称之为painting

#### 页面的重绘和回流

- 重绘指的是当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color，visibility，outline等。
  重绘不会带来重新布局，并不一定伴随回流（重排）。

- 回流(reflow)指的是当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，即渲染树需要重新计算。也就是说，回流是指DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证DOM树上的所有其他节点的visibility属性，因此，回流是低效的。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。
  - 可能会产生回流的情况：
    - DOM树的结构变化：例如节点的增减、移动等。
    - 元素尺寸改变（边距、填充、边框、宽度和高度）
    - 获取某些属性：当获取一些属性时，浏览器为取得正确的值也会触发重排。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。
    - 内容改变，比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
    - 页面渲染初始化；
    - 浏览器窗口尺寸改变，如resize事件发生时。
- 两者的关系
  - 回流必将引起重绘，而重绘不一定会引起回流。

#### 重绘和重排(回流)的优化方案

- 元素位置移动变换时尽量使用css3里面的transform来代替top,left等操作变换
- 使用opacity来代替visibility
  - 使用visibility不触发重排，但是依旧重绘
  - 使用opacity即触发重绘，又触发重排(GPU底层设计如此)
  - opacity配合图层使用，即不触发重绘也不触发重排
  - 原因：透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并需要整体的重绘，不过这个前提是这个被修改的opacity本身是一个图层
- 不要使用table布局(table-cell)
- 将多次样式属性的操作合并成一次操作
  - 不要一条一条的修改DOM的样式，预先定义好class然后修改DOM的classname
- 将DOM离线后再修改
  - 由于display属性为none的元素在不渲染树种，对隐藏的元素操作不会引发其他元素的重排，如果有对一个元素进行复杂的操作，可以先隐藏它，操作完成后再显示，这样只在隐藏和显示时触发两次重排 

#### BFC

- 概念
  块状格式化上下文
  全名：block formatting context
- 触发bfc的条件
  html根元素
  float：left/right
  position：absolute/fixed
  overflow：不是visible（默认值）
  display：inline-block/flex(弹性盒)/inline-flex(行内弹性盒)/table-cell(单元格)
- bfc区域的布局规则
  bfc区域的元素从上到下依次排列
  相邻的上下两个元素的垂直方向的距离由margin控制，距离以大的为准
  bfc区域里面的元素的margin-left和bfc区域的border-left相接触
  bfc区域与外界毫不相干
  bfc区域不和浮动元素相重叠
  计算bfc区域，浮动元素参与计算
- bfc的应用
  解决margin重叠
  两栏布局
  清除浮动带来的负面影响（高度塌陷）

#### CSS中伪类和伪元素

- 伪类
  :active 向被激活的元素添加样式。
  :focus 向拥有键盘输入焦点的元素添加样式。
  :hover 当鼠标悬浮在元素上方时，向元素添加样式。
  :link 向未被访问的链接添加样式。
  :visited 向已被访问的链接添加样式。
  :first-child 向元素的第一个子元素添加样式。
  :lang 向带有指定 lang 属性的元素添加样式

- 伪元素
  ::first-letter，将特殊的样式添加到文本的首字母。
  ::first-line，将特殊的样式添加到文本的首行。
  ::before，在某元素之前插入某些内容。
  ::after，在某元素之后插入某些内容。

#### 1px线

- 1px 问题的由来

  - 在做移动端项目时，有一个逃不掉的问题：在手机上，1px的细线会看起来更宽。其实这不仅是手机上会出现的问题，准确来说，这是高清屏的“通病”，在高清的PC上也会同样有。
    高清屏是指高dpr的设备，dpr指物理像素/css像素，这样的设备其物理像素的密度更大。又可以细分为两倍屏，三倍屏。
  - 将高清屏下的像素映射关系代入1px线的场景中，会发现：2倍屏下的线宽是2个物理像素，3倍屏下是3个。数学中有个概念：线是没有宽度的，点是没有大小的。像素同样是没有大小的。2倍屏的物理像素密度是普通屏的两倍，并不是每一个物理像素大小是普通屏的1/4，而是物理像素的间距是普通屏间距的1/2。2倍屏下用两排像素去展示，自然会比普通屏下用一排像素去展示，看起来更粗。

- 如何修正1px问题
  要解决1px问题，本质就是让高清屏用一个物理像素去展示一个css像素。
  最简单粗暴的方式：在2倍屏下将1px的细线写成border:0.5px。但这种方法只在iOS上支持，安卓上会显示成被当成0px处理。
  更通用的方案中，有svg和伪类元素两种。

  - SVG方案

    - 方法1：svg标签

    ```
    <svg xmlns="custom-namespace" width="100" height="100">
        <rect
            width="100"
            height="100"
            fill="transparent"
            // 宽度1px
            stroke-width="1"
            stroke="black"
        />    
    </svg>    
    ```

    - 通常会使用postcss-write-svg这个插件，让我们直接在css文件定义svg

      ```
      // 定义svg函数
      @svg custom-name {
        width: 4px;
        height: 4px;
        @rect {
          fill: transparent;
          width: 100%;
          height: 100%;
          stroke-width: 1;
          stroke: var(--color, black);
        }
      }
      .svg-retina-border {
        border: 1px solid;  
        border-image: svg(custom-name param(--color green)) 1 repeat;
      }
      .normal-border {
        border: px solid green;
      }
      ```

  - 伪类元素方案

    - 这种方案借助伪类元素::before，在需要添加边框的元素之上加一个“蒙层”。

      ```
      .target {
        position: relative;
      }
      .target::before {
        width: 200%;
        height: 200%;
        border: 1px solid #333;
        transform: scale(0.5);
        content: '';
        position: absolute;
        top: 0px;
        right: 0px;
        transform-origin: left top;
        box-sizing: border-box;
        pointer-events: none;
      }
      ```

  - 该选哪种方案？（伪类元素居多）

    - svg方案需要考虑border-image的兼容性，伪类元素方案需要考虑transform的兼容性。svg的兼容性更好。
    - 由于svg只能画出特定的形状，所以无法实现圆角边框。而伪类元素方案可以。伪类元素灵活性更好。
    - 综合上述的考虑，我们的项目选择的是伪类元素方案，因为使用圆角边框的地方很多。而且从两种方案的篇幅不难看出来，这个方案的学习成本也低很多。

#### 数据类型；

- 7种基本类型（Number,String,Boolean,Undefined,Null,Symbol,BigInt），1种引用类型（Object）
- symbol指的是独一无二的值，使用方式类似于函数，接收一个字符串作为参数，主要就是用来预防对象的属性出现重名覆盖的问题。
- BigInt是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用BigInt，整数溢出将不再是问题。要创建BigInt，只需在整数的末尾追加n即可,可以进行任意的运算。

#### 判断数据类型方法；

- typeof前期可以作为基本检测使用，对于对象的检测是不清晰

- toString是最好的数据类型的检测。
  Object.prototype.toString.call({})  [objet Object]
  Object.prototype.toString.call(null)  [objet Null]
  Object.prototype.toString.call(undefined)  [objet Undefined]

- constructor返回对象的构造函数，弊端: constructor 所指向的的构造函数是可以被修改的
  let arr = [1,2,3];
  console.log(arr.constructor);//function Array(){ [native code]}

- instanceof对象从属于哪个类，包括原型链(Object)，但Array 和 Object 都出现在 [] 的原型链上，可能会将 [] 误认为 Object 类型
  let arr = [1,2,3];
  console.log(arr instanceof Array);//true
  console.log(arr instanceof Object);//true

#### 深浅拷贝；

- 浅拷贝就是通过赋值的方式进行拷贝，那为什么说这是浅拷贝呢？就是因为赋值的方式只会把对象的表层赋值给一个新的对象，简单来说，浅拷贝就是只复制引用，而未复
- 制真正的值，如果里面有属性值为数组或者对象的属性，那么就只会拷贝到该属性在栈空间的指针地址，新对象的这些属性数据就会跟旧对象公用一份，也就是说两个地址
  指向同一份数据，一个改变就会都改变。
    - 数组 
      - concat、slice
      - 使用等号实现数组的浅拷贝,如果数组的元素是基本数据类型，那么会直接克隆该元素到新数组，如果元素是复杂类型时，克隆的则是复杂类型的指向，这种情况
        下，无论是新数组还是旧数组，改变了复杂类型，两个数组都会受到一样的影响
    - 对象
      - Object.assign()
      - ... 展开运算符

- 深拷贝则是直接复制父对象在堆内存中的对象，最终在堆内存中生成一个独立的，与父对象无关的新对象。深拷贝的对象虽然与父对象无关，但是却与父对象一致。当深拷
  贝完成之后，如果对父对象进行了改变，不会影响到深拷贝的副本，同理反之亦然。
    - js数组中实现深拷贝的方法有很多，比如JSON.parse(JSON.stringify())、递归以及jQuery库的extend方法，lodash的cloneDeep方法都是可以实现数组和对象的深拷贝的。
    - 如果在深拷贝的过程中遇到循环引用怎么办？
      -  用一个Map来存储应用类型，然后每次遇到引用属性，就用has查看是否已经有了这个引用

- 通过Map来解决循环引用的代码  

```
function deepClone(target, map = new Map()) {
  // 判断数据类型
  if (typeof target === "object" || target !== null) {
    // 克隆数据之前，进行判断，数据之前是否克隆过
    let cache = map.get(target);
    if (cache) {
      return cache;
    }

    // 判断目标数据的类型
    let isArray = Array.isArray(target);
    // 创建容器
    const result = isArray ? [] : {};

    // 将新的结果存入到容器中
    map.set(target, result);
    if (isArray) {
      // 如果是数组则直接使用forEach进行遍历
      target.forEach((item, index) => {
        result[index] = deepClone(item, map);
      });
    } else {
      // 如果是对象，则先获取所有的键名，然后forEach遍历
      Object.keys(target).forEach((key) => {
        result[key] = deepClone(target[key], map);
      });
    }
    return result;
  } else {
    return target;
  }
}
```


- 通过递归实现深拷贝的代码演示

  ```
  let person = {
    uname: '张三',
    age: 22,
    sex: '男',
    arr: ['小明', '大大', '小小'],
    obj: {
      index: 1,
      name: '三和'
    },
    say: function () {
      console.log('hello javascript')
    }
  }
  let son = {}
  
  function myCopy(newObj, obj) {
    for(let key in obj) {
      if (obj[key] instanceof Array) {
        newObj[key] = []
        myCopy(newObj[key], obj[key])
      } else if (obj[key] instanceof Object) {
        newObj[key] = {}
        myCopy(newObj[key], obj[key])
      } else {
        newObj[key] = obj[key]
      }
    }
  }
  
  // 调用递归函数
  myCopy(son, person)
  
  person.arr.push('小王')
  console.log(son)
  console.log(person)
  ```

- 通过js的反序列化实现深拷贝代码

  ```
  let person = {
    uname: '张三',
    age: 22,
    sex: '男',
    arr: ['小明', '大大', '小小'],
    obj: {
      index: 1,
      name: '三和'
    },
    say: function () {
      console.log('hello javascript')
    }
  }
  
  function myCopy(obj) {
    let _obj = JSON.stringify(obj)
    let newObj = JSON.parse(_obj)
    return newObj
  }
  
  let son = myCopy(person)
  
  person.arr.push('小王')
  console.log(son)
  console.log(person)
  ```

- 通过 jQuery 封装的方法($.extend())实现深拷贝【必须先引入 jQuery，第一个参数必须是 true】

  ```
  let person = {
    uname: '张三',
    age: 22,
    sex: '男',
    arr: ['小明', '大大', '小小'],
    obj: {
      index: 1,
      name: '三和'
    },
    say: function () {
      console.log('hello javascript')
    }
  }
  
  let son = {}
  
  $.extend(true, son, person) // 通过 $.extend() 方法实现深拷贝
  // 第一个参数必须是 true
  
  person.arr.push('小王')
  console.log(son)
  console.log(person)
  ```

#### 防抖和节流；

-  很多事件触发频率很高，影响性能。
-  函数的防抖：（debounce）
   -  当事件被触发一段时间后再执行事件，如果在这段时间内事件又被触发，则重新计时。
   -  在事件触发时开始计时，在规定的时间内，若再次触发事件，将上一次计时清空，然后重新开始计时。保证只有在规定时间内没有再次触发事件之后，再去执行这个事件。
   -  生活中的实例： 如果有人进电梯，那电梯将在10秒钟后出发，这时如果又有人进电梯了，我们又得等10秒再出发（重新计时）

-  函数节流（throttle）：指定时间间隔内，若事件被多次触发，只会执行一次.
   - 在事件触发之后开始计时，在规定的时间内，若再次触发事件，不对此事件做任何处理。保证在规定时间内只执行一次事件.

#### this指向；

- 非严格模式下this指向默认是window,严格模式下默认是undefined
- 普通函数调用，this指向全局对象window
- 对象函数调用，谁调用this就指向谁
- 构造函数调用，this指向实例对象
- 事件处理函数，this指向事件对象
- 箭头函数，this指向父级。箭头函数的this是在定义函数的时候绑定的，不是在执行过程中绑定的
- 可以通过call,apply,bind修改this的指向；也可以提前将this保存下来

#### 数组方法；

- 栈方法：push(),pop()
- 队列方法：unshift(),shift()
- 重排序方法：reverse(),sort()
- 操作方法：concat(),slice(),splice()
- 转换方法：join()
- 位置方法：indexOf(),lastIndexOf()
- 迭代方法：forEach(),map(),filter(),every(),some()
- 归并方法：reduce(),reduceRight()
- 扁平化方法：flat()
- 包含：includes()

#### 元素水平垂直居中的方法

- 【方法1：利用vertical-align】
  在需要水平垂直居中的元素后面添加一个空的span标签，不换行，不空格，然后将该元素以及span标签都转换为行内块元素，垂直对齐方式都设置为中线对齐方式，最后设置span标签高度为100%，父元素文本水平居中（text-align:center;）即可；
  关键代码
  span{
      display:inline-block;
      height:100%;
      vertical-align:middle;
  }
  元素{
      display:inline-block;
      vertical-align:middle;
  }
  父元素{
      text-align:center;
  }

- 【方法2：利用margin（需要知道父元素和子元素的宽高）】
  将子元素的上下外边距设置为父元素与子元素高度差值的一半，水平居中即可，不要忘记解决父元素高度塌陷的问题
  关键代码
  父元素{
      overflow:hidden;
  }
  子元素{
      margin:(父元素高度-子元素高度)/2  auto;
  }

- 【方法3：利用绝对定位（需要知道子元素的宽高）】
  子绝父相，子元素距离父元素上和左都为50%，然后将子元素向上和向左调整距离为子元素宽高的一半即可
  关键代码
  父元素{
      position:relative;
  }
  子元素{
      position:absolute;
      top:50%;
      left:50%;
      margin-top:-子元素高度的一半;
      margin-left:-子元素宽度的一半;
  }

- 【方法4：利用绝对定位（不需要知道父元素和子元素的宽高）】
  子绝父相，子元素距离父元素上下左右都为0，水平margin:auto居中即可
  关键代码
  父元素{
      position:relative;
  }
  子元素{
      position:absolute;
      top:0;
      left:0;
      right:0
      bottom:0
      margin:auto;
  }

- 【方法5：利用绝对定位以及平移（不需要知道父元素和子元素的宽高）】
  子绝父相，子元素距离父元素上和左都为50%，然后将子元素通过平移效果，向上和向左分别为自身宽高的一半即可
  关键代码
  父元素{
      position:relative;
  }
  子元素{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%)
  }

- 【方法6：利用弹性盒（不需要知道父元素和子元素的宽高）】
  父元素转为弹性盒，在主轴方向和侧轴方向上的对齐方式都修改为中心即可
  关键代码
  父元素{
      display:flex;
      justify-content:center;
      align-items:center;
  }

- 【方法7：利用网格布局（不需要知道父元素和子元素的宽高）】
  父元素转为网格布局，将单元格内容水平和垂直对齐方式都修改为center
  关键代码
  父元素{
      display:grid;
      place-items:center;
  }

#### 在项目中有封装过什么组件 举几个例子(你封装过组件吗？？说一下组件封装？？？？你在项目中是如何封装组件的？？？？？)

- Vue:
  - 答： 我用vue/react开发的所有项目，都是采用组件化的思想开发的。一般我在搭建项目的时候，会创建一个views目录和一个commen目录和一个feature目录，views目录中放页面级的组件，commen中放公共组件（如：head（公共头组件），foot（公共底部组件）等），feature目录内放功能组件（如：swiper(轮播功能组件)，tabbar(切换功能组件)、list(上拉加载更多功能组件)）
  - 首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性低等问题。

  - 如何封装组件
    - Vue:
      - 使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。但是我们一般用脚手架开发项目，每个 .vue单文件就是一个组件。在另一组件import 导入，并在components中注册，子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。

    - react中的组件不同于vue,将UI结构、逻辑和样式分开，在react中是通过一个js文件来实现的，分为函数组件和类组件之分。

#### 函数组件和类组件的区别？

- 函数组件是一个纯函数，它接收一个props对象返回一个react元素；而类组件需要去继承React.Component并且创建render函数返回react元素。
- 函数组件可以直接调用，返回一个新的react元素；而类组件在调用的时候是需要创建一个实例的，然后通过调用实例里的render方法来返回react元素。
- 函数组件没有生命周期和状态state，而类组件有。

#### 项目中有遇见什么问题

- 在一个小程序项目需求中，要求页面头部tab栏切换的同时，对应tab栏品类的页面也要展示出来。你可能会觉得这个需求用个taroUI组件库中的tabs标签页组件不就可以完成吗？但是这个需求想满足用户的沉浸式体验，切换页面时需要有独特丝滑的专场特效。所以当时面临的问题就是，使用的UI库的组件默认样式生硬，满足不了需求。我当时是对小程序原生swiper组件进行了二次封装，主要实现了几点自定义需求：头部Tab栏品类样式使用flex动态布局，实现品类数量可变；使用 slot 插槽来动态渲染 Tab区块中的内容，配合原生swiper组件使用定义插槽；小程序原生组件<swiper>是有默认高度的，必须手动设置其高度，这里使用wx.getSystemInfo来动态获取屏幕尺寸。自己封装组件，踩了不少坑，但从中我学习到了：使用小程序的原生组件，并修改其默认的样式；学会使用 slot 插槽，实现组件内容的差异化；学会了使用小程序原生 api 获取手机信息，用 js 改变组件样式等等

#### undefined和null的区别；

- 用一句话总结两者的区别就是：undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。

#### js异步编程的了解

- 异步编程是为了解决同步模式的一些痛点，同步模式中任务是依次执行，后一个任务必须要等待前一个任务结束后才能开始执行，当某个函数耗时过长时就可能造成页面的假死和卡顿，而异步编程中，后一个任务不会去等待前一个任务结束后才开始，当前一个任务开启过后就立即往后执行下一个任务。耗时函数的后续逻辑会通过回调函数的方式定义。在内部，耗时任务完成过后就会自动执行传入的回调函数。
- 引入异步任务是为了提高代码执行的效率和速度，但个人理解觉得这只是结果的一部分，还是有一点js这门语言的缺陷在的，js作为一种单线程语言，意味着它在处理 多任务并发时 没有了多线程语言（如java）的优势，一个主线程下代码只得一行行执行，cpu的多核能力也不能完全发挥，所以异步任务的引入在一定程度上也提升了js在处理多任务的能力吧。

#### promise中怎么抛出错误

- 在构造函数中抛出错误：无论是否有catch，都会进入reject处理，状态变为fullfilled（注意不是rejected）：
- 在resolve或reject中抛出错误：没有catch时会抛到全局，状态变为rejected，有catch时则被捕获，状态变为fullfilled：
- throw抛出错误会阻塞后续执行
- 在构造函数中将抛出错误语句放在定时器里，catch捕获不到

#### 样式link引入，style引入，哪个层级高，link和@import导入的区别是什么？

- 理论上是内嵌高于链接，但实际上：内嵌和链接在同一个文件头部，谁离相应的代码近，谁的优先级高
- 导入方式的区别
  - 从本质上来看，link是XHTML标签，而import是css提供的一种方式
  - 从加载顺序上，link是当前页面被加载的时候同时加载，而import引入的css会先等页面加载完毕之后再加载，所以如果import方式在网速比较慢的时候，会出现闪烁的效果，影响用户体验
  - link引入的文件可以被js操作，@import不可以
  - 当使用Js控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的
  - 兼容性上的区别，@import是css2.1提出的，所以老的浏览器是不支持的，而link标签无此问题

#### css布局，左侧宽度最小150px，最大25 %，右侧自适应。怎么实现

- 一个大的div里面包含左侧和右侧的div，给最大的div设置弹性盒，左侧的宽度给定最小宽度为150px,最大宽度为25%，右侧flex为1

#### 表单可以跨域吗？为什么？

- 表单是可以跨域的。首先，跨域问题产生的原因是由于浏览器的同源策略，浏览器同源策略的本质是，一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。但浏览器并不阻止你向另一个域名发送请求。
- 表单可以跨域，是因为form提交是不会携带cookie的，你也没办法设置一个hidden的表单项，然后通过js拿到其他域的cookie，因为cookie是基于域的，无法访问其他域的cookie，所以浏览器认为form提交到某个域，是无法利用浏览器和这个域之间建立的cookie和cookie中的session的，故而，浏览器没有限制表单提交的跨域问题。 
- form表单不会出现跨域问题，因为页面进行了跳转，并且form表单页没有读取其他页面信息的

#### CSS3的新特性

- 我们项目中比较常用的有：边框圆角（border-radius）、边框图片（border-image） 、阴影（box-shadow、text-shadow）、颜色(rgba)、渐变（linear-gradient、radial-gradient）、过渡效果（transition、transition-property、transition-duration、transition-timing-function、transition-delay）、旋转（transform、translate、rotate、scale、rotate、skew）、动画（animation）、媒体查询（@media）、弹性盒子（flex），还新增了一些选择器（比如说E:nth-child(n)、E:nth-of-type(n)、E:frist-child等）、媒体查询等，

#### H5新特性

- 新增
  - 1、拖拽释放（drag and drop）API
  - 2、语义化更好的内容标签（header footer nav aside article section）
  - 3、音频、视频（audio video）API
  - 4、画布（Canvas）API
  - 5、地理（Geolocation）API
  - 6、localstorage 和 sessionstorage 缓存方式
  - 7、表单控件（calendar date time email ul search）
  - 8、新技术（webworker websocket Geolocation）

- 移除的元素
  - 1、纯表现元素：basefont font big center s tt u strike
  - 2、对可用性有负面影响的元素：frame frameset noframes

#### 不同机型的兼容问题（移动端适配&微信小程序适配）

- 移动端适配
  - 方法一：rem + 媒体查询
    设置html的font-size: 50px/100px (好算)
    根据媒体查询判断不同的设备，计算不同设备的html的font-size大小
    所有的尺寸改为rem单位
  - 方法二：rem + vw 适配
    320px 的屏幕下  100vw = 320px  1vw = 3.2px
     html的50px 可以转换为  50/3.2 = 15.625vw
  - 方法三：flexble.js插件
    font-size = width * 50 /320
    所有的px单位转为rem
    引入js文件   js文件中设备的宽度手动调整
    去掉视口代码  name = 'viewport'

- 微信小程序
  - 将px换算成rpx

#### 怎么理解弹性布局的？

- 弹性布局（flex），它可以让结构中的内容自适应不同的分辨率，简化了许多繁琐的代码。
- 弹性盒只影响子元素，不会影响孙元素
- 弹性盒子里面的子元素的float,clear,vertical-align失效
- 弹性盒的伸缩项目会自动产生一个块级框，可以设置宽高
- 弹性布局的语法分为两种：加给父容器的语法; 加给子项目的语法
  - 加给父容器的语法：
    - display:flex;
    - flex-direction;
    - flex-wrap;
    - flex-grow;
    - justify-content;
    - align-items;
    - align-content;

  - 加给子容器的语法
    - order;
    - flex-grow;
    - flex-shrink;
    - flex-basis;
    - flex;
    - align-self;

#### flex:1 代表哪三个参数，这三个参数的默认值分别是什么？

- flex-grow:元素的扩展比率，分配主轴上的剩余空间
  - 默认为0，不扩展
  - 只有在容器宽度大于伸缩项目总宽的时候生效
- flex-shrink:元素的收缩比率，当主轴空间不足的时候收缩
  - 默认为1，收缩，如果修改为0表示不收缩
  - 只有在容器宽度小于伸缩项目总宽的时候生效
- flex-basis:伸缩项目的基准值
  - 默认是auto
  - 还可以填数值和百分比
  - 当元素宽度和flex-basis都不是默认值的事后，元素宽度以flex-basis为准，如果元素有宽度，flex-basis设置为默认值的时候，元素宽度以width为准；元素有flex-basis，宽度设置为默认值的时候，元素的宽度以flex-basis为准，当元素的宽度和flex-basisi都没有设置的时候元素宽度由内容物撑开
- flex:1     --->flex-grow:1,flex-shrink:1;flex-basis:0%
- flex:auto  --->flex-grow:1;flex-shrink:1;flex-basis:auto;
- flex:none  --->flex-grow:0;flex-shrink:0;flex-basis:auto;


#### less和scss相对于css有什么优势？

- less和scss编译后会生成正常的css文件，但是为css增加一些编程特性(定义变量、嵌套、混合、继承、if语句、循环判断等)，无需考虑浏览器的兼容性（完全兼容css3），让css更加简洁、适应性更强，可读性更佳，更易于代码的维护等诸多好处。
- 但要注意的是scss支持循环判断，但less不支持

#### 什么是样式穿透？

- 在vue开发过程中，当我们引入第三方组件库时(如使用element-ui)，需要在局部组件中修改第三方组件库样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过一些方法穿透scoped。
- css里面用>>>来实现 
- scss中用::v-deep来实现
- less中用/deep/来实现

#### 什么是虚拟dom？为什么要用虚拟dom?虚拟dom具体做了什么？

- 什么是虚拟dom?
  - 虚拟DOM就是一个用来描述真实dom结构的js对象，因为它不是真实的dom，所以才叫做虚拟dom。

- 为什么要使用虚拟dom?
  - 虚拟DOM本身是为了解决浏览器性能问题而被设计出来的，浏览器的一个渲染原理是先将获取到的html文档解析成dom树，将css样式表解析成css树，再将dom树和css树合并成渲染树，将渲染树的每个元素经过精确计算之后给出坐标，再将各个节点绘制到屏幕上。如果使用传统的js操作dom树的话，浏览器会执行整个流程，所以直接操作DOM的代价比较大。

  - 那么虚拟dom是不会立即操作DOM的，而是使用diff算法，先将diff内容保存在一个js对象中，然后进行新旧虚拟dom的比较,等更新完，再将最终的js对象映射成真实的DOM，交由浏览器绘制，减少了dom操作，避免了大量无谓的计算，提升了渲染性能。
- 虚拟dom的作用
  - 可以维护视图和状态之间的关系
  - 复杂视图情况下提升渲染性能
  - 虚拟DOM除了可以渲染成DOM节点，还可以渲染到其他平台如ssr(nuxt.js/next.js)、原生应用（weex/rn）、小程序等，增加了跨平台能力

#### react项目优化；

- 性能优化：shouldComponentUpdate()、PureComponent、immutable、精灵图、懒加载、usecallback()+memo、渲染时加key

#### promise;

- promise 表示承诺，是Es6新增的可以解决回调地狱的问题，它是一个构造函数。
- Promise 异步编程的一种解决方案，比传统的解决方案（回调函数）更合理和更强大。
- Promise 对象代表一个异步操作，有三种状态：pending进行中、fulfilled成功、rejected失败。
- promise是异步的，异步指的是promise下面的then和catch是异步的。
- 它有两个特点
  - 1.对象的状态不受外界影响
  - 2.一旦状态设定，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected,只要这两种情况发生，状态就凝固了.

#### Promise 避免回调地狱的语法糖--实现链式调用的核心点是什么？

- 解决回调地狱的终极方法 async/await ES7的语法，可以通过 async/await让代码看起来像同步的
  - async异步 await等待
    - await 等待 就是当后面跟的是promise对象，就让他停止，先让里面的异步事情做完，在把结果返回给前面的新变量，在继续向后执行，它只生效当前作用域内部，也就是async函数内部。

- 实现链式调用的核心点:
  - 在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是then 中产生的 Promise)，同时下一个Promise的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…


#### 闭包；

- 只要你把一个函数里面的函数，作为 return的方式返回到外边，扔给一个变量。只要做这个事刚才的调用就产生了闭包。闭包的形成与变量的作用域以及变量的生存周期有关的，生存周期对于全局变量是永久的，除非我们主动销毁这个全局变量，而对于在函数内用var关键字声明的局部变量来说，当退出函数时，它们都会随着函数调用的结束而被销毁.闭包可以让在函数中定义的变量不会随着外部函数调用结束而销毁，延长了变量的作用域，并且避免了全局的污染。但是与此同时，由于这种特性，闭包会使得内部变量一直存在，变量常驻内存，会增加内存的使用，这个时候我们需要手动销毁，给变量设置为null，但如果使用不当也会造成内存泄露。

- 闭包的特点
  - 函数嵌套函数
  - 内部函数使用外部函数的参数和变量 (函数的参数相当于函数内部的变量)
  - 函数参数和变量不会被垃圾回收机制回收,闭包可以使得它诞生环境一直存在

- 闭包的优缺点
  - 闭包的好处：希望一个变量长期存储在内存中（延长变量作用域）避免全局的污染，私有成员（函数内部的变量）的存在。
  - 闭包的缺点：闭包使得内部的变量一直存在，变量常驻内存，增加内存使用量--手动销毁，设为null使用不当会造成内存泄漏
    - 内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。当变量标记为离开环境或者变量引用计数为0，而垃圾回收机制无法回收时，就会产生内存泄漏。

- 闭包的应用场景
  - 如果我们从别人的地方copy过来的代码的变量和自己的变量重复，两段代码分开都运行正常，但是放到一起可能就会出错，所以用闭包的方法把他们封装在一个函数里面返回出来，就可以避免这种情况发生。
  - 函数的防抖节流
  - 柯里化函数
  - 用闭包模拟私有化方法
  - 计数器、延迟调用、回调等
  - 核心思想都是创建私有变量和延长变量的生命周期

#### 原型，原型链

- 原型
  - 每一个函数都有一个原型对象(属性对象)，原型上面绑定是公有的属性或者方法，而且里面的this依然指向实例对象。

- 原型链
  - 实例对象与原型(prototype)之间的连接，叫做原型链，原型链依靠__proto__(新版浏览器中采用[[Prototype]])进行连接。每个对象都有一个__proto__（内部原型）属性,原型链上的对象正是依靠这个属性连结在一起.
  - 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。
    - ①一直往上层查找，直到null还没有找到，则返回undefined
    - ②Object.prototype.__proto__ === null
    - ③所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象

#### TCP三次握手和四次挥手

- 三次握手

  - 概念：三次握手(three-way handshake)，翻译为：需要三个步骤才能建立握手/连接的机制。也可以叫 three-message handshake，通过三条消息来建立的握手/连接。
  - 作用：主要就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号(Init Sequense Number, ISN)为后面的可靠性传输做准备。
  - 关键词解释
    - ISN：初始化序列号 
    - SYN：连接请求/接收 报文段
    - seq：发送的第一个字节的序号
    - ACK：确认报文段
    - ack：确认号。希望收到的下一个数据的第一个字节的序号 
  - 过程：
    - 第一次握手：客户端发送syn报文，并发送seq为x序列号给服务端，等待服务端的确认。
    - 第二次握手：服务端发送syn+ack报文，并发送seq为Y的序列号，再确认序列号为x+1
    - 第三次握手：客户端发送ack报文，并发送seq序列号为z，再确认序列号为y+1，结束握手

  - 为什么要三次握手？
    - 三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
      只有经过三次握手才能确认双发的收发功能都正常，缺一不可：
        第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常
        第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：客户端确认了自己发送、接收正常，对方发送、接收正常；服务器确认了对方发送正常，自己接收正常
        第三次握手（客户端发送 ACK 报文给服务器）：客户端确认了自己发送、接收正常，对方发送、接收正常；服务器确认了自己发送、接收正常，对方发送、接收正常

  - ISN (Initial Sequence Number) 是固定的吗？
    - 不是，因为三次握手其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。
      当一端为建立连接而发送它的 SYN 时，它会为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。
      如果 ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

  - 三次握手过程中可以携带数据吗？
    - 第一次和第二次握手的时候不能携带，第三次可以。
    - 理由：假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。
      而对于第三次的话，此时客户端已经处于ESTABLISHED(确立)状态。对于客户端来说，它已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。
    - 简单的记忆就是，请求连接/接收 即 SYN = 1的时候不能携带数据

  - 如果第三次握手丢失了，客户端服务端会如何处理？
    - 服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。
      注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

- 四次挥手

  - 概念：建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手。这是由于 TCP 的半关闭（half-close）特性造成的，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(Four-way handshake)，客户端或服务端均可主动发起挥手动作。 

  - 关键词解释

    - FIN ：连接终止位
    - seq：发送的第一个字节的序号
    - ACK：确认报文段
    - ack：确认号。希望收到的下一个数据的第一个字节的序号

  - 过程：
    第一次挥手：先由客户端向服务器端发送一个FIN，请求关闭数据传输。
        第一次挥手：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并停止再发送数据，主动关闭 TCP 连接。此时客户端处于 FIN_WAIT1 状态，等待服务端的确认。【FIN_WAIT1-等待远程TCP的连接中断请求，或先前的连接中断请求的确认】

    第二次挥手：当服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ack的值等于FIN+SEQ
        第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。【CLOSE-WAIT - 等待从本地用户发来的连接中断请求】；
        此时的 TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文
        段。【FIN-WAIT-2 - 从远程TCP等待连接中断请求】

    第三次挥手：然后服务器向客户端发送一个FIN，告诉客户端应用程序关闭。
        第三次挥手：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认。【LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认】

    第四次挥手：当客户端收到服务器端的FIN是，回复一个ACK给服务器端。其中ack的值等于FIN+SEQ
        第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 TIME_WAIT（时间等待）状态。【TIME-WAIT - 等待足够的时间以确保远程TCP接收到连接中断请求的确认】

  - 为什么要四次挥手？

    - 由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
      任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
    - 通俗的来说，两次挥手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次挥手。
      举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

#### http协议有了解过吗？

- HTTP协议的主要特点可概括如下：
  - 1.支持客户/服务器模式。
  - 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
  - 3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。
  - 4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
  - 5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

#### http的无连接和无状态怎么理解？

- 无连接
  - 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 
  - 原因：
    - 早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间
      交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用
      资源。因此 HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。
    - 随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，Keep-Alive 被提出用来解决这效率低的问题。

- 无状态
  - http协议呢，是一种超文本传输协议，而为什么说http协议是无状态的呢，是因为当浏览器第一次发送数据给服务器时，服务器响应了；如果同一浏览器，向服务器第二次发送请求时，它还是会响应，但服务器并不知道你就是刚才那个浏览器。简而言之，服务器是不会记住你是谁的，所以是无状态的。而如果要使http协议有状态，就可以使浏览器访问服务器时，加入cookie，这样，只要你在请求时有了这个cookie，服务器就能够通过cookie知道，你就是之前那个浏览器，这样的话，http协议就有状态了。
  - 这种无状态的特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。客户端
    与服务器进行动态交互的 Web 应用程序出现之后，HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。

#### cookie和session是怎么工作的？

- Cookie
  - Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了（当然，不排除用户手工删除Cookie）。而还有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私。

  - 工作流程简述
    - 客户端访问服务端-->服务端响应并颁发cookie给客户端--->客户端携带cookie请求服务器

  - 典型应用
    - 是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用
      场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。

- Session
  - Session是通过服务器来保持状态的。当客户端访问服务器时，服务器根据需求设置Session，将会话信息保存在服务器上，同时将标示 Session 的 SessionId 传递给客户端浏览器，浏览器将这个 SessionId 保存在内存中，我们称之为无过期时间的 Cookie。浏览器关闭后，这个 Cookie 就会被清掉，它不会存在于用户的 Cookie 临时文件。以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个 SessionId，就能取得客户端的数据信息。如果客户端浏览器意外关闭，服务器保存的 Session 数据不是立即释放，此时数据还会存在，只要我们知道那个 SessionId，就可以继续通过请求获得此 Session 的信息，因为此时后台的 Session 还存在，当然我们可以设置一个 Session 超时时间，一旦超过规定时间没有客户端请求时，服务器就会清除对应 SessionId 的 Session 信息。

  - 工作流程简述
    - 客户端访问服务端--->服务端生成session并把sessionID添加到cookie--->客户端携带cookie访问服务端--->服务端通过sessionID获取session识别客户端，并做出响应 

#### cookies、sessionStorage 和 localStorage 的区别？

-1.存储大小
    cookie数据大小不能超过4k。
    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

- 2.有效时间
  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
  sessionStorage  数据在当前浏览器窗口关闭后自动删除。
  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
- 3. 数据与服务器之间的交互方式
     cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端
     sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

#### 跨域

- 为什么会产生跨域？

  - 因为浏览器的同源策略
    - 同源策略就是浏览器最核心最安全的安全功能，主要是为了阻止一个域名去访问另一个域名上面的数据

- 什么情况下会产生跨域？ 

  - 域名不同
  - 端口不同
  - 协议不同
  - 域名和域名对应的IP地址会产生跨域
  - 一级域名和二级域名会产生跨域

- 解决跨域的方法

  - 后端使用cors跨站资源共享，在需要共享的第三方接口添加两句常规代码

    - 代码：header('Access-Control-Allow-Origin:*') ; header('Access-Control-Allow-Method:POST,GET');

  - 前端解决方案：

    - jsonp

      - jsonp的特点：script标签src属性不存在跨域；通过自定义函数获取数据(形参获取数据),自定义函数名称在地址栏上面，一般的名称：cb,callback；
      - 弊端：仅支持get请求，很多信息通过地址栏进行维护

    - 反向代理(比较常用的方法)

      - 在devServer中配置proxy对象

        ```
        devServer:{
            //设置代理
            proxy: { //代理是从指定的target后面开始匹配的，不是任意位置；配置pathRewrite可以做替换
              '/api': { //原网址中第一个路径参数
               		 target: 'http://localhost:3001', // 协议+域名
               		 changeOrigin: true, //创建虚拟服务器 
                  	pathRewrite: { // 这一步可要可不要
                        '^/api': ''    //重写接口，去掉/api， 在代理过程中是否替换掉/api/路径 
             		}
              	}
              }
           }
        ```

#### http状态码

- 5种常见的HTTP状态码
  200 (ok) : 请求已成功, 请求所希望的响应头或数据体将随此响应返回
  303 (See Other) : 告知客户端使用另一个URL来获取资源
  400 (Bad Request) : 请求格式错误. 1)语义有误; 2)请求参数有误
  404 (Not Found) : 请求失败, 请求所希望的到的资源未被服务器发现
  500 (Internal Server Error) : 服务器遇到了一个未曾预料的情况, 导致了它无法完成对请求的处理

- 更多状态码
  100 => 正在初始化 (一般看不到)
  101 => 正在切换协议 (websocket 浏览器提供的) 
  202 => 表示接受
  301 => 永久重定向 / 永久转
  移
  302 => 临时重定向 / 临时转移 (一般用来作服务器负载均衡)
  304 => 本次获取的内容是读取缓存中的数据, 会每次去服务器校验
  401 =>  未认证, 没有登录网站
  403 => 禁止访问, 没有权限
  503 => 服务器超负荷

#### http和https有什么区别

- http是超文本传输协议，信息是明文传输，https 则是在http的基础上加了一层加密层（ssl），所以是具有安全性的ssl加密传输协议
- http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。
- http的连接很简单,是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全
- https协议需要到ca申请证书，一般免费证书很少，需要交费。

#### HTTP1.0、HTTP1.1、HTTP2.0、HTTP 3.0

- http1.0
  - 1.0的HTTP版本，是一种无状态，无连接的应用层协议。 HTTP1.0规定浏览器和服务器保持短暂的链接。
  - 浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接(无连接)，服务器不跟踪也每个客户单，也不记录过去的请求(无状态)。
  - 这种无状态性可以借助cookie/session机制来做身份认证和状态记录。

  - 存在的问题
    - 无法复用连接，每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。
    - 队头阻塞(head of line blocking)，由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。
    - 不支持断点续传，也就是说，每次都会传送全部的页面和数据。

-http1.1
    - HTTP1.1继承了HTTP1.0的简单，克服了HTTP1.0性能上的问题。
    - 特点
        - 长连接，HTTP1.1增加Connection字段，对于同一个host，通过设置Keep-Alive保持HTTP连接不断。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。
        - 如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求。
        - 支持断点续传，通过使用请求头中的 Range 来实现。
        - 可以使用管道传输，多个请求可以同时发送，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。
          要是前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。

- http2.0
  - http2.0是一种安全高效的下一代http传输协议。安全是因为http2.0建立在https协议的基础上，高效是因为它是通过二进制分帧来进行数据传输。正因为这些特性，http2.0协议也在被越来越多的网站支持。据统计，截止至2018年8月，已经有27.9%的网站支持http2.0。

  - 特点
    - HTTP2.0 支持明文传输，而 HTTP 1.X 强制使用 SSL/TLS 加密传输。
    - 和 HTTP 1.x 使用的 header 压缩方法不同。
    - HTTP2.0 基于二进制格式进行解析，而 HTTP 1.x 基于文本格式进行解析。
    - 多路复用，HTTP1.1 是多个请求串行化单线程处理，HTTP 2.0 是并行执行，一个请求超时并不会影响其他请求 

- http3.0
  - 基于Google的QUIC，HTTP3 背后的主要思想是放弃 TCP，转而使用基于 UDP 的 QUIC 协议。 
  - 特点：
    - 线头阻塞(HOL)问题的解决更为彻底：
      基于 TCP 的 HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于 UDP 的 QUIC协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。

    - 切换网络时的连接保持：
      当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi 断开，网络切换为 3G 或 4G。基于 TCP 的协议，由于切换网络之后，IP 会改变，因而之前的连接不可能继续保持。而基于 UDP 的 QUIC 协议，则可以内建与 TCP 中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接 


### React相关面试题

#### react框架的优缺点

- 特性：
  - 声明式设计：react采用声明范式，可以轻松描述应用
  - 高效：react通过对dom的模拟，最大限度地减少与dom的交互
  - 灵活：react可以与已知的库或框架很好地配合
- 优点：
  - 虚拟dom：虚拟dom减少了真实dom的操作，帮助我们解决了跨浏览器问题，他为我们提供了标准化的API，甚至在IE8中都是没问题的。
  - 组件系统：使用react开发的核心就是将页面拆分成若干个组件，并且react一个组件中同时耦合了css、js、image，这种模式整个颠覆了过去的传统的方式
  - 单向数据流：其实reactjs的核心内容就是数据绑定，所谓数据绑定指的是只要将一些服务端的数据和前端页面绑定好，开发者只关注实现业务就行了
  - jsx语法：在vue中，我们使用render函数来构建组件的dom结构性能较高，因为省去了查找和编译模板的过程，但是在render中利用createElement创建结构的时候代码可读性较低，较为复杂，此时可以利用jsx语法来在render中创建dom，解决这个问题，但是前提是需要使用工具来编译jsx
- 缺点：
  - React本身只是一个View(视图层)而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和redux才能写大型应用。 

#### redux有什么优缺点

- 优点：
  - redux轻量，生态丰富，可以结合流行的redux-thunk、redux-saga等中间件进行使用
  - redux写法比较固定，团队应用中风格比较稳定，提高协作中的可维护性
  - 因为redux中的reducer更新时，每次return的都是不可变对象，所以时间行操作相对容易
- 缺点：
  - 每一次的dispatch都会从根reducer到子reducer嵌套递归的执行，所以效率相对较低
  - redux核心是不可变对象，在reducer中的操作要比较小心，注意不能修改到state的属性
  - redux中写法比较固定，模板代码较多
  - 由于Redux 是一个内存状态存储。如果应用程序崩溃，将丢失整个应用程序状态。这意味着我们必须使用缓存解决方案来创建应用程序状态的备份，会产生额外的开销。

#### 一般什么时候使用redux？

- 一般在不知道是不是要使用redux的时候，通常都是不需要使用的，只有遇到 React 实在解决不了的问题，才需要 Redux。
- 需要使用到redux的项目有：
  - 用户的使用方式复杂,也就是说用户操作的每一步的状态都需要去记录(还是状态复杂)
  - 不同身份的用户有不同的使用方式（比如普通用户和管理员）
  - 多个用户之间可以协作
  - 与服务器大量交互，或者使用了WebSocket
  - View要从多个来源获取数据
  - 某个组件的状态,需要做到共享
  - 一个组件需要改变全局的组件

#### react组件的key说一下 key发生变化会发生什么 key 值不同销毁前会触发什么生命周期，可以使用index作为key值吗？

- react利用key来识别组件，每个key对应一个组件，相同的key，react认为是同一个组件，这样后续相同的key对应组件都不会被创建。
- 有了key属性后，就可以与组件建立了一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件。
  - key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。
  - key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件。
  - setState：谁用到了所更新的state，就会刷新该组件，render也并不是所有都会变化，只变state改变的部分。
  - 另外需要指明的是:key不是用来提升react的性能的，不过用好key对性能是有帮组的。
- 如果你去改变某个组件的key值的话，它会在下次渲染的时候被销毁并当作新的组件重新渲染进来
- 一般不建议使用index作为key值，在只涉及到数据展示的时候并不会出现什么问题，但是当我们在操作数据时候，很容易出现问题。比如在页面中渲染3 个 input 输入框，然后依次输入随机内容，当我们用 index 作为 key 的时候，点击删除第一项按钮会发现，左侧文字正确改变，input 输入框最后一项没了。这就是因为当我们使用 index 作为 key 时，此时 key 为 0、1、2，删掉第一项后 key 变为 0、1，此时 react 在执行 diff 算法过程中，任务 key=0 存在，只需要更新子节点的值，所以左侧的 name 成功改变，而 input 的值非受控，不会更新。同时在对比计算中少了 key=2 这项，删除了最后一项。当我们使用id 作为 key 时，此时 key 为 1、2，3，删掉第一项后 key 变为 2、3，根据 react 的 diff 算法，react 计算出删除一个子节点即可更新.

#### 组件通信

- **子传父通信**
  - 父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变
  - 父组件利用`ref`对子组件做标记，通过调用子组件的方法以更改子组件的状态,也可以调用子组件的方法..

- **父传子通信**
  - 父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过`this.props`接收到父组件的方法后调用。

- **跨组件通信**
  - 在react没有类似vue中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系。react提供了`context` api来实现跨组件通信, React 16.3之后的`context`api较之前的好用。
  - 在react里面导入createContext，这是一个方法，执行这个方法，里面有Provider和Consumer，把Provider套在传递信息的组件上，添加value属性，Consumer套在接收信息的组件上，里面有个回调函数。

#### react/vue/angular这些框架共有的传参方式有哪些？

- 组件传参
  - 父子传参
  - 子父传参
  - 跨组件传参
- 第三方的（vuex,redux）
- 路由传参
- 第三方的localStorage\session\cookie等

#### react生命周期；

- 老版本的生命周期
  - 初始化阶段
    - constructor()
      - constructor是当类被实例化的时候，就自动执行，并且是最先执行的
      - constructor可以接收一个参数props
  - 挂载阶段
    - componentWillMount()
      - 被废弃，如果要使用，需要在前面添加UNSAFE_
    - render()
      - render不仅仅是挂载的时候执行，更新的时候还会执行
      - render一定要返回一个jsx
      - render不能做数据请求(fiber算法的原因)
    - componentDidMount()
      - 这里面就啥都可以做了 
  - 更新阶段
    - states更新
      - shouldComponentUpdate(nextProps, nextState)
        - 两个参数分别表示新的props和新的state
        - 将Component改为PureComponent时，这个生命周期可以不用
      - componentWillUpdate()
        - 被废弃，如果使用需要在前面加上UNSAFE_
      - render()
      - componentDidUpdate()
        - 可以拿到更新以后的值，在这里不要去更改数据,可能会造成死循环

    - props更新
      - componentWillReciveProps() 
        - 组件的props更新的时候会触发
        - 被废弃，如果使用需要在前面加上UNSAFE_
      - shouldComponentUpdate(nextProps, nextState)
        - 两个参数分别表示新的props和新的state
        - 将Component改为PureComponent时，这个生命周期可以不用 
      - componentWillUpdate()
      - render()
      - componentDidUpdate()
  - 卸载阶段
    - componentWillUnmount()
      - 组件被销毁的时候调用
      - 关闭定时器，关闭websocket，解除js的事件监听，卸载第三方插件

- 新版本的生命周期
  - 常用的生命周期
    - constructor()
    - render()
    - componentDidMount()
    - componentDidUpdate()
    - componentWillUnmount()
  - 完整的生命周期
    - constructor()
    - static getDerivedFromProps()
      - 表示根据props的值去生成一个新的state
      - 里面要接受两个参数(props和state)
      - 前面必须要加static, 组件必须要有state
      - 还必须去返回一个对象或者null
    - shouldComponentUpdate()
    - render()
    - getSnapShotBeforeUpdate()
      - 在更新之前去获取一个快照(记录)
      - 必须要和componentDidUpdate一起配合使用
        - getSnapshotBeforeUpdate(prevProps, prevState)
        - componentDidUpdate(prevProps, prevState, snapshot)
      - 去返回一个值或者null
      - 只有在ui处理(涉及到一些跟css样式相关的东西才有作用)的时候可能会用到
    - componentDidMount()
    - componentDidUpdate()
    - componentWillUnmount()

#### setState是同步还是异步？

    - 17版本及以前
        - 1. setState在合成事件和生命周期里面是异步的
        - 2. setState在定时器和原生js里面是同步的
    - 18版本，就一律是异步的了

#### 首页的加载速度

- 加载速度比较慢，这是因为目前主流的前端框架React、Vue、Angular都是采用客户端渲染（服务端渲染暂时不在本文的考虑范围内），浏览器的压力比较大，大量的js文件需要在本地运行，而从服务器下载这些大的js文件需要时间，再运行这些js又需要时间，从而导致首页加载速度比较慢。
- 因为后续有缓存的存在，其他页面加载相对就比较快了。
- 可以提升速度的方法
  - 提高下载静态资源的速度
    - 升级HTTP1.1到HTTP2.0,开启gzip数据压缩，上cdn等
    - 通过webpack的UglifyJsPlugin插件对代码进行压缩
    - 提取第三方库
    - 服务器端渲染首屏
  - 优化代码提高运行速度 
    -  利用React的懒加载，在用webpack打包的时候进行代码的分割，减少首屏加载的体积。

#### 了解路由hash模式跟history模式 history模式基于什么api实现的 hash模式的缺点

- hash模式: 即地址栏 URL 中带有 # 符号的模式,是通过监听浏览器onhashchange触发的路由模式.
- history模式是利用了 HTML5 中 pushState() 和 replaceState() 这两个API实现的。

- 区别:
  - 1.url 展示上，hash 模式有“#”，history 模式没有
  - 2.hash 值的改变不会重新加载页面。因为它的值不会被包含在请求中路径上,所以修改也不会影响请求的路径.
  - 3.history模式下，前端的url必须和实际向后端发起请求的url 一致.否则刷新会跳转到404页面
  - 4.hash 兼容性更强, 可以支持低版本浏览器和 IE。

- hash模式的优缺点
  - 优点:
    - (1) 只需要前端配置路由表, 不需要后端的参与
    - (2) 兼容性好, 浏览器都能支持
    - (3) hash值改变不会向后端发送请求, 完全属于前端路由
  - 缺点:
    - hash值前面需要加#, 不符合url规范,也不美观

- history模式的优缺点
  - 优点
    - 符合url地址规范, 不需要#, 使用起来比较美观 
  - 缺点
    - (1) 在用户手动输入地址或刷新页面时会发起url请求, 后端需要配置index.html页面用户匹配不到静态资源的情况, 否则会出现404错误
    - (2) 兼容性比较差, 是利用了 HTML5 History对象中新增的 pushState() 和 replaceState() 方法,需要特定浏览器的支持.

#### 知道react里面的createPortal么？ 使用场景是什么？ 之前react没有这个的时候是怎么实现的？ 有他没他的区别？

- portal 即传送门，它可以将组件渲染到指定元素下，而不限于当前书写的 JSX 层级结构

- 当需要将某个元素始终保持在顶层时，可以使用 protal 将其传入到 body 下，需注意的是虽然被传送的元素没有按书写的JSX层级渲染，但是事件冒泡仍然和被传送之前一样

- Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。

  - ReactDOM.createPortal(child, container)
    - 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment。第二个参数（container）是一个 DOM 元素。

- 使用场景：

  - 一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框 
  - overflow:hidden
  - 父组件的z-index值太小
  - fixed需要放在body第一层级

- 没有createPortal之前，实现传送门会使用到，unstable_renderSubtreeIntoContainer和unmountComponentAtNode两个API

  - unstable_renderSubtreeIntoContainer：作用就是建立“传送门”，可以把JSX代表的组件结构塞到传送门里面去，让他们在传送门的另一端渲染出来。

    ```
    unstable_renderSubtreeIntoContainer(
          this, //代表当前组件
          <div class="dialog">
            {props.children}
          </div>, // 塞进传送门的JSX
          this.node // 传送门另一端的DOM node
        );
    ```

  - unmountComponentAtNode用来清理第一个API的副作用，通常在unmount的时候调用，不调用的话会造成资源泄露的。 

- 有了Portal之后就不需要牵扯到componentDidMount、componentDidUpdate，也不用调用API清理Portal，关键代码在render中，就很简单。


#### usecallback跟usememo说一下以及是否可以达成一个效果

- useCallback缓存的是函数本身，useMemo缓存的是函数的返回值
- useMemo可以改写useCallback，但useCallback不能改写useMemo

#### usestate是否异步

- useState 返回的更新状态方法是异步的，要在下次重绘才能获取新值。不要试图在更改状态之后立马获取状态。
- 解决方法:应该使用useRef 存储这个数据,在useEffect里监听data的变化

#### 说说hooks

- hooks是react16.8以后才新增的内容,hooks都是给函数组件用的，为了让函数组件能够拥有类组件的功能
- hooks还可以解决高阶组件让层级变深的问题
- 路由提供的hooks主要还是用于获取路由信息的
- 所有的hooks都是use开头的，都必须在函数组件的顶层调用
- 使用 React Hooks 相比于从前的类组件有以下几点好处：
  - 代码可读性更强，原本同一块功能的代码逻辑被拆分在了不同的生命周期函数中，容易使开发者不利于维护和迭代，通过 React Hooks 可以将功能代码聚合，方便阅读维护
  - 组件树层级变浅

#### react hooks有什么

- useState[保存组件状态]
  调用useState会返回一个数组, 数组里面是变量和改变变量的方法

  - useState要接受一个参数，参数就是这个变量的初始值
    如果改变以后的值不依赖前一次的值，直接里面写值
    如果需要依赖到，参数写函数,改变数据的方法的是异步的，这里没有回调函数的
    如果想得到改变以后的结果，需要配合useEffect一起使用

  ```
  import React, { useState } from "react";
  const App = () => {
    const [count, setCount] = useState(5);
    const handleClick = () => {
      setCount((v) => v + 1);
      console.log(count);
    };
    const [num, setNum] = useState(10);
    return (
      <>
        <h2>useState</h2>
        <span>{count}</span>
        <button onClick={handleClick}>+</button>
        <p>{num}</p>
        <button onClick={() => setNum((v) => v + 2)}>++</button>
      </>
    );
  };
  export default App;
  ```

- useEffect[处理副作用]
  useEffect调用的时候没有返回值的,里面需要传入参数
  第一个参数是回调函数
      如果回调函数里面返回一个函数，那么返回的函数里面相当于componentWillUnmount
  第二个参数是一个数组, 数组里面写的是依赖
      如果只有一个参数，那么就相当于componentDidMount以及componentDidUpdate；如果有第二个参数，并且是一个空数组，那么相当于componentDidMount,如果第二个参数有依赖，那么相当于watch
      constructor的内容是可以放在函数组件里面直接写的
  useEffect可以多次执行
      如果在useEffect里面去调用封装好的请求，那么我们要使用自执行函数

```
import React, { useEffect, useState } from "react";

const getData = () => {
  return fetch("http://www.pudge.wang:3080/api/rated/list")
    .then((response) => response.json())
    .then((res) => {
      return res;
    });
};

const App = () => {
  const [count, setCount] = useState(5);
  const [num, setNum] = useState(10);
  // useEffect(() => {
  //   console.log(count);
  // }, [count]);

  // useEffect(() => {
  //   return () => {
  //     console.log("组件被卸载了");
  //   };
  // }, []);

  // useEffect(() => {
  //   const timer = setInterval(() => {
  //     console.log(12333);
  //   }, 1000);
  //   return () => {
  //     clearInterval(timer);
  //   };
  // }, []);

  useEffect(() => {
    (async () => {
      const res = await getData();
      console.log(res);
    })();
  }, []);

  return (
    <>
      <h2>useEffect</h2>
      <p>{count}</p>
      <button onClick={() => setCount((v) => v + 1)}>btn</button>
      <p>{num}</p>
      <button onClick={() => setNum((v) => v + 1)}>btn</button>
    </>
  );
};

export default App;
```


- useCallback[记忆函数]
  useCallback叫做缓存函数，里面是两个参数，第一个参数是函数体，第二个参数是数组依赖，返回值还是函数
  当这个函数要作为自定义事件进行传递的时候，就必须要加useCallback
  memo是一个高阶组件，作用和PureComponent一模一样，它是给函数组件用的

  ```
  import React, { useState, memo, useCallback } from "react";
  const Child = memo(() => {
    console.log("child render");
    return <div>child组件</div>;
  });
  const App = () => {
    const [count, setCount] = useState(5);
    const fn = () => {
      setCount((v) => v + 1);
    };
    const fn2 = useCallback(() => {
      console.log("count");
    }, []);
    return (
      <>
        <h2>useCallback</h2>
        <p>{count}</p>
        <button onClick={fn}>+</button>
        <Child doSomething={fn2} />
      </>
    );
  };
  ```


- useMemo[记忆组件]
  useMemo也是用来缓存函数的，语法和useCallback完全相同
  类似于vue的计算属性
  useCallback和useMemo的区别

- useCallback缓存的是函数本身
  useMemo缓存的是函数的返回值
  useContext[减少组件层级]

- useContext主要是用于简化Consumer的接收的
  用于useContext,createContext还是必须要有的
  useContext需要接受context对象作为参数，并且可以返回出它对应的value属性

  ```
  import React, { createContext, useContext } from "react";
  
  const context1 = createContext();
  const context2 = createContext();
  
  const Child2 = () => {
    const { name } = useContext(context1);
    const { nickName } = useContext(context2);
    return (
      <p>
        child2组件 - {name} - {nickName}
      </p>
      // <context1.Consumer>
      //   {(value) => (
      //     <context2.Consumer>
      //       {(val) => (
      //         <p>
      //           child2组件 - {value.name} - {val.nickName}
      //         </p>
      //       )}
      //     </context2.Consumer>
      //   )}
      // </context1.Consumer>
    );
  };
  
  const Child1 = () => {
    return (
      <context2.Provider
        value={{
          nickName: "xiaosan",
        }}
      >
        <p>child1组件</p>
        <Child2 />
      </context2.Provider>
    );
  };
  
  const App = () => {
    return (
      <context1.Provider
        value={{
          name: "zhangsan",
        }}
      >
        <h2>useContext</h2>
        <Child1 />
      </context1.Provider>
    );
  };
  
  export default App;
  ```


- useReducer[类似于redux]
  useReducer调用的时候可以接收两个参数,分别是reducer函数以及state的初始值
  useReducer会有一个返回值，返回值是一个数组, 分别是state以及dispatch

  ```
  import React, { useReducer } from "react";
  
  const defaultState = {
    count: 5,
  };
  
  const reducer = (state, action) => {
    switch (action.type) {
      case "increment":
        return {
          ...state,
          count: state.count + 1,
        };
      case "decrement":
        return {
          ...state,
          count: state.count - 1,
        };
      default:
        return state;
    }
  };
  
  const App = () => {
    const [state, dispatch] = useReducer(reducer, defaultState);
    return (
      <>
        <h2>useReducer</h2>
        <button onClick={() => dispatch({ type: "decrement" })}>-</button>
        <span>{state.count}</span>
        <button onClick={() => dispatch({ type: "increment" })}>+</button>
      </>
    );
  };
  
  export default App;
  ```


#### 脚手架怎么从css升级成less？

- 第一种可以通过执行命令 yarn eject 将脚手架预先封闭的Webpack等配置工具的源文件暴露出来自行添加;
- 但我一般使用第二种方式，就是使用customize-cra、react-app-rewired对配置进行扩展；
  - 先安装customize-cra、react-app-rewired依赖 
    - yarn add customize-cra react-app-rewired --save-dev 
  - 再安装less依赖
    - yarn add less less-loader@5.0.0  --save-dev 
  - 在项目的根目录下创建名称为config-overrides的文件。不需要加js后缀
  - 还需要将package.json文件内scripts节点的start、build更新
    - "start": "react-app-rewired start",
    - "build": "react-app-rewired build", 
  - 最后将脚手架内原有的css文件更改为less格式，再引入 

#### react的错误边界(Error Boundaries)

- Error Boundaries 是 React16 提出来用来捕获渲染时错误的概念，它是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，且会渲染出兜底 UI。
- 如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。
  - static getDerivedStateFromError：在出错后有机会修改 state 触发最后一次错误 fallback 的渲染。
  - componentDidCatch：用于出错时副作用代码，比如错误上报等。
- 错误边界的工作方式类似于 JavaScript 的 catch {}，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为错误边界组件。 
- 有四种情况是错误边界无法捕获的
  - 回调事件，由于回调事件执行时机不在渲染周期内，因此无法被 Error Boundaries Catch 住，如有必要得自行 try/catch
  - 异步代码，比如 setTimeout 或 requestAnimationFrame，和第一条同理
  - 服务端渲染
  - Error Boundaries 组件自身触发的错误，只能捕获其子组件的错误

#### 高阶组件的使用

- Higher-Order Components就是一个函数，传给它一个组件，它返回一个新的组件
- 将多个组件的相同逻辑代码，抽象到HOC中，让组件更有结构化，更易于复用。HOC不破坏传入组件的特性，只通过组合形成新组件。HOC是纯函数，没有副作用。
- 步骤
  - 创建一个函数，名称约定以with开头
  - 指定函数参数，参数应该以大写字母开头
  - 在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回
  - 在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件
  - 调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面

